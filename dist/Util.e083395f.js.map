{"mappings":";;;;;;AAAA;AAKO,MAAM;IACX,OAAO,uBAAuB,GAAW,EAAE,GAAW,EAAE;QACtD,OAAO,KAAK,KAAK,CAAC,KAAK,MAAM,KAAM,CAAA,MAAM,MAAM,CAAA,IAAK;IACtD;IAEA;;;;GAIC,GACD,OAAO,oBAAoB,iBAA0B,EAAE;QACrD,IAAI,mBACF,OAAO,kBACJ,KAAK,CAAC,KACN,MAAM,CAAC,CAAC,UAAY,SACpB,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;aAEpB,OAAO,EAAE;IAEb;IAEA;;;;;GAKC,GACD,OAAO,iBAAiB,IAAW,EAAE,IAAW,EAAE;QAChD,SAAS,WAAW,KAAU,EAAE,KAAa,EAAE,IAAW;YACxD,OAAO,KAAK,OAAO,CAAC,WAAW;QACjC;QAEA,IAAI,uBAAuB,KAAK,MAAM,CAAC,MAAM,MAAM,CAAC;QACpD,OAAO;IACT;IAEA;;;GAGC,GACD,OAAO,cAAc,cAAsB,EAAE;QAC3C,OAAO,IAAI,KAAK,SAAS,eAAe,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,MAAM;IAC9E;IAEA;;;;GAIC,GACD,OAAO,SAAS,GAAG,KAAe,EAAsB;QACtD,iDAAiD;QACjD,IAAI,QAAe,EAAE;QACrB,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAI,GAAG,IAC3C,QAAQ,MAAM,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,KAAK,CAAC;QAE1C,4DAA4D;QAC5D,IAAI,WAAW,EAAE;QACjB,IAAK,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAI,GAAG,IAAK;YACxC,IAAI,OAAO,KAAK,CAAC,EAAE;YACnB,sCAAsC;YACtC,2BAA2B;YAC3B,IAAI,CAAC,QAAQ,SAAS,KAAK;YAC3B,yCAAyC;YACzC,IAAI,SAAS,MAAM,SAAS,GAAG;iBAE1B,SAAS,IAAI,CAAC;QACrB;QACA,+CAA+C;QAC/C,IAAI,KAAK,CAAC,EAAE,KAAK,IAAI,SAAS,OAAO,CAAC;QACtC,uCAAuC;QACvC,OAAO,SAAS,IAAI,CAAC,QAAS,CAAA,SAAS,MAAM,GAAG,MAAM,GAAE;IAC1D;IAEA;;;;GAIC,GACD,OAAO,QAAQ,IAAY,EAAE;QAC3B,YAAY;QACZ,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM;IAC7B;IAEA;;GAEC,GACD,OAAO,iBAAiB,GAAW,EAAU;QAC3C,MAAM,YAAY,IAAI,OAAO,CAAC,YAAY,CAAC,OAAO,KAAO,CAAC,CAAC,EAAE,GAAG,WAAW,IAAI;QAE/E,OAAO,UAAU,UAAU,CAAC,OAAO,UAAU,KAAK,CAAC,KAAK;IAC1D;IAEA,4DAA4D,GAC5D,OAAO,cAAc,MAA2B,EAAE,MAA8B,EAAE;QAChF,OAAO,OAAO,OAAO,CAAC,QAAQ,MAAM,CAAC,CAAC,GAAG,CAAC,KAAK,OAAO;YACpD,CAAC,CAAC,OAAO,GAAG,MAAM,CAAC,IAAI;YACvB,OAAO;QACT,GAAG,CAAC;IACN;AACF,EAAE,YAAY","sources":["src/helper/Util.ts"],"sourcesContent":["ï»¿'use strict'\r\n\r\n/**\r\n * Old util class from 2017, will be merged to CommonHelper\r\n */\r\nexport class Util {\r\n  static GetRandomNumberBetween(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min)\r\n  }\r\n\r\n  /**\r\n   * split string into array, remove empty entries, each output string is trimmed\r\n   * \"1,2,3 ,,, 4, 5 ,6\" ==> [1,2,3,4,5,6]\r\n   * @param strCommaSeparated\r\n   */\r\n  static splitByCommaAndTrim(strCommaSeparated?: string) {\r\n    if (strCommaSeparated) {\r\n      return strCommaSeparated\r\n        .split(',')\r\n        .filter((segment) => segment)\r\n        .map((e) => e.trim())\r\n    } else {\r\n      return []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * merge 2 arrays of entries and reduce to distinct\r\n   * [1,2,3] & [2, 3, 4] ==> return [1,2,3,4]\r\n   * @param {Array} arr1\r\n   * @param {Array} arr2\r\n   */\r\n  static mergeAndDistinct(arr1: any[], arr2: any[]) {\r\n    function onlyUnique(value: any, index: number, self: any[]) {\r\n      return self.indexOf(value) === index\r\n    }\r\n\r\n    let distinctArrayOfRoles = arr1.concat(arr2).filter(onlyUnique)\r\n    return distinctArrayOfRoles\r\n  }\r\n\r\n  /**\r\n   * give you the Date object, from the jsonDateString (return from some API services)\r\n   * @param jsonDateString string of this format \"/Date(2342353453434)/\"\r\n   */\r\n  static parseJsonDate(jsonDateString: string) {\r\n    return new Date(parseInt(jsonDateString.replace('/Date(', '').replace(')/', '')))\r\n  }\r\n\r\n  /**\r\n   * Joins path segments.  Preserves initial \"/\" and resolves \"..\" and \".\"\r\n   * Does not support using \"..\" to go above/outside the root.\r\n   * This means that join(\"foo\", \"../../bar\") will not resolve to \"../bar\"\r\n   */\r\n  static joinPath(...paths: string[] /* path segments */) {\r\n    // Split the inputs into a list of path commands.\r\n    var parts: any[] = []\r\n    for (var i = 0, l = arguments.length; i < l; i++) {\r\n      parts = parts.concat(arguments[i].split('/'))\r\n    }\r\n    // Interpret the path commands to get the new resolved path.\r\n    var newParts = []\r\n    for (i = 0, l = parts.length; i < l; i++) {\r\n      var part = parts[i]\r\n      // Remove leading and trailing slashes\r\n      // Also remove \".\" segments\r\n      if (!part || part === '.') continue\r\n      // Interpret \"..\" to pop the last segment\r\n      if (part === '..') newParts.pop()\r\n      // Push new path segments.\r\n      else newParts.push(part)\r\n    }\r\n    // Preserve the initial slash if there was one.\r\n    if (parts[0] === '') newParts.unshift('')\r\n    // Turn back into a single string path.\r\n    return newParts.join('/') || (newParts.length ? '/' : '.')\r\n  }\r\n\r\n  /**\r\n   * A simple function to get the dirname of a path\r\n   * Trailing slashes are ignored. Leading slash is preserved.\r\n   * @param path\r\n   */\r\n  static dirname(path: string) {\r\n    // ts-ignore\r\n    return this.joinPath(path, '..')\r\n  }\r\n\r\n  /** convert camelCase to snake_case\r\n   * @example someHereIsGood ==> some_here_is_good. CAPITALIZED ==> c_a_p_i_t_a_l_i_z_e_d\r\n   */\r\n  static camelToSnakeCase(str: string): string {\r\n    const snakeCase = str.replace(/([A-Z])/g, (match, p1) => `_${p1.toLowerCase()}`)\r\n\r\n    return snakeCase.startsWith('_') ? snakeCase.slice(1) : snakeCase\r\n  }\r\n\r\n  /** (from source), create new object contains mapped fields */\r\n  static objectMapKeys(source: Record<string, any>, keyMap: Record<string, string>) {\r\n    return Object.entries(keyMap).reduce((o, [key, newKey]) => {\r\n      o[newKey] = source[key]\r\n      return o\r\n    }, {} as any)\r\n  }\r\n} // end class\r\n"],"names":[],"version":3,"file":"Util.e083395f.js.map"}